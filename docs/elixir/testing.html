<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Testing: Stoic API :: Elixir Full-Stack</title>
    <link rel="canonical" href="https://elixircl.github.io/elixir-fullstack/elixir/testing.html">
    <link rel="prev" href="liveview.html">
    <link rel="next" href="commands.html">
    <meta name="generator" content="Antora 3.1.12">
    <link rel="stylesheet" href="../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://elixircl.github.io/elixir-fullstack">Elixir Full-Stack</a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <!--
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
    -->
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="ROOT" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">Elixir Full-Stack</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Historia</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../history/chapter.html">Historia de la World Wide Web y Aplicaciones Móviles</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Ecosistema Tecnológico y Laboral</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ecosystem/jobs.html">Mundo Laboral y su Estado del Arte</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ecosystem/web.html">Ecosistema Web</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ecosystem/llm.html">Large Language Models (LLM)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Ingeniería en Software</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../swe/stages.html">Etapas del Desarrollo de un Producto de Software</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../swe/patterns.html">Patrones y Arquitecturas de Software</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../swe/adr.html">Arquitecture Decision Records</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../swe/prd.html">Documento de Requerimiento de Producto (Product Requirement Document - PRD)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../swe/wow.html">Way of Work</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../swe/uat.html">Pruebas de Aceptación de Usuario (User Aceptance Testing - UAT)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../swe/deprecation.html">Versionado y Política de Compatibilidad y Obsolescencia</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Github</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../github/chapter.html">Github, Static Site Generators, Markdown, Linux y Vim</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Hostings</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../hosting/chapter.html">Hosting, Dominios y Cpanel</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Networking</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../networking/chapter.html">Redes e Internet</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">HTTP</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../http/chapter.html">HTTP, JSON y APIS</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">HTML</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../html/chapter.html">HTML, CSS y GIT</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Javascript</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../javascript/chapter.html">Frontend con Javascript</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Elixir</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="elixir.html">El Lenguaje Elixir</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="apirest.html">REST: Stoic API</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="liveview.html">LiveView: Stoic API</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="testing.html">Testing: Stoic API</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="commands.html">Makefiles</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Aplicaciones Móviles</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../mobile/chapter.html">Aplicaciones Móviles</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../mobile/pwa.html">Progresive Web Apps</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">DevOps</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../devops/devenvs.html">Ambientes de Desarrollo</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../devops/observability.html">Observabilidad e Instrumentación</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../devops/dora.html">Métricas DORA</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../devops/golden.html">Golden Signals</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Elixir Full-Stack</span>
    <span class="version">Spanish</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../index.html">Elixir Full-Stack</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">Spanish</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Elixir Full-Stack</a></li>
    <li>Elixir</li>
    <li><a href="testing.html">Testing: Stoic API</a></li>
  </ul>
</nav>
<div class="edit-this-page"><a href="file:///antora/./modules/elixir/pages/testing.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Testing: Stoic API</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>En este tutorial se verá como realizar pruebas tanto para la API Rest, los esquemas
y el formulario creado en los tutoriales anteriores.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-1-verificación-del-ambiente-testing"><a class="anchor" href="#paso-1-verificación-del-ambiente-testing"></a>Paso 1: Verificación del Ambiente Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En el directorio <code>config/</code> se encuentra las distintas configuraciones
para la conexión con la base de datos y otros elementos para distintos ambientes. <code>dev</code>, <code>prod</code> y <code>test</code>.
Además de dos archivos especiales <code>config.exs</code> y <code>runtime.exs</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>dev</code>: Configuraciones para el ambiente de desarrollo local.</p>
</li>
<li>
<p><code>prod</code>: Configuraciones para el ambiente en producción.</p>
</li>
<li>
<p><code>test</code>: Configuraciones para el ambiente de pruebas locales.</p>
</li>
<li>
<p><code>config.exs</code>: Configuraciones en tiempo de compilación. No puede acceder a variables de entorno en tiempo de ejecución. Además llamará a <code>dev</code>, <code>prod</code> y <code>test</code> respectivamente
según la variable de entorno <a href="https://hexdocs.pm/elixir/1.18.4/introduction-to-mix.html#environments">MIX_ENV</a>.</p>
</li>
<li>
<p><code>runtime.exs</code>: Configuraciones que pueden acceder a variables de entorno en tiempo de ejecución (antes de iniciar la aplicación).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los archivos importantes son <code>config.exs</code> y <code>runtime.exs</code> los otros archivos pueden ser
estructurados según sea conveniente para la aplicación, y se pueden importar con
<a href="https://hexdocs.pm/elixir/1.18.4/Config.html#import_config/1">import_config/1</a> dentro de <code>config.exs</code>
aunque no dentro de <code>runtime.exs</code> (limitaciones técnicas).</p>
</div>
<div class="paragraph">
<p>Dentro del archivo <code>config/test.exs</code> podemos verificar que la conexión
con la base de datos se esté realizando en una nueva base de datos de pruebas
en modo <em>Sandbox</em> (que cualquier cambio sea efímero).</p>
</div>
<div class="listingblock">
<div class="title">config/test.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">config :stoic_quotes, StoicQuotes.Repo,
  database: Path.expand("../stoic_quotes_test.db", __DIR__),
  pool_size: 5,
  pool: Ecto.Adapters.SQL.Sandbox</code></pre>
</div>
</div>
<div class="paragraph">
<p>También debemos borrar algunos archivos en la suit de pruebas debido
a que solo son ejemplos predeterminados creados para probar la página de bienvenida.</p>
</div>
<div class="paragraph">
<p>Se deben borrar los siguientes archivos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>stoic_quotes_web/controllers/error_html_test.exs</code></p>
</li>
<li>
<p><code>stoic_quotes_web/controllers/error_json_test.exs</code></p>
</li>
<li>
<p><code>stoic_quotes_web/controllers/page_controller_test.exs</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Podemos verificar que la suit de pruebas de ejecuta exitosamente con el comando</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Y ver un resultado similar a lo siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Compiling 23 files (.ex)
Running ExUnit with seed: 93697, max_cases: 8

.........
Finished in 0.3 seconds (0.00s async, 0.3s sync)
9 tests, 0 failures</code></pre>
</div>
</div>
<div class="paragraph">
<p>¿Dónde están esas 9 pruebas?. Están en el archivo <code>test/stoic_quotes/quotes_test.exs</code>
que fue creado por el generador del contexto (<code>mix phx.gen.context</code>) usado en el tutorial de
la api rest.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-2-pruebas-de-ecto-schema"><a class="anchor" href="#paso-2-pruebas-de-ecto-schema"></a>Paso 2: Pruebas de Ecto Schema</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Se realizarán las pruebas de los esquemas creados. Se debe probar que los campos tengan
su tipo de datos adecuado. Como recordatorio se muestra el esquema a probar.</p>
</div>
<div class="listingblock">
<div class="title">lib/stoic_quotes/quotes/quote.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotes.Quotes.Quote do
  use Ecto.Schema
  import Ecto.Changeset

  @optional_fields [:id, :inserted_at, :updated_at]

  schema "quotes" do
    field(:quote, :string)
    field(:author, :string)
    field(:source, :string)

    timestamps(type: :utc_datetime)
  end

  def fields() do
    __MODULE__.__schema__(:fields)
  end

  def required_fields() do
    fields() -- @optional_fields
  end

  @doc false
  def changeset(quote, attrs) do
    quote
    |&gt; cast(attrs, fields())
    |&gt; validate_required(required_fields())
    |&gt; unsafe_validate_unique(:quote, StoicQuotes.Repo)
    |&gt; unique_constraint(:quote)
  end

  @doc false
  def new(attrs \\ %{"author" =&gt; "", "quote" =&gt; "", "source" =&gt; ""}) do
    case changeset(%__MODULE__{}, attrs) do
      {_, changeset} -&gt; changeset
      changeset -&gt; changeset
    end
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para crear la prueba se crea un nuevo archivo en <code>test/stoic_quotes/quotes/schema_test.exs</code></p>
</div>
<div class="listingblock">
<div class="title">test/stoic_quotes/quotes/schema_test.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotes.Tests.Schemas.Quotes.QuoteSchemaTest do
  use StoicQuotes.DataCase
  alias StoicQuotes.Quotes.Quote

  describe "quote schema field and types tests" do
    test "that schema has the correct fields and types" do
      expected_fields_and_types = [
        {:id, :id},
        {:quote, :string},
        {:author, :string},
        {:source, :string},
        {:inserted_at, :utc_datetime},
        {:updated_at, :utc_datetime}
      ]

      actual_fields_and_types =
        for field &lt;- Quote.__schema__(:fields) do
          type = Quote.__schema__(:type, field)
          {field, type}
        end

      assert MapSet.new(expected_fields_and_types) == MapSet.new(actual_fields_and_types)
    end
  end
end</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>defmodule StoicQuotes.Tests.Schemas.Quotes.QuoteSchemaTest</code>: Nombre del módulo siempre debe terminar en <code>Test</code>.</p>
</li>
<li>
<p><code>use StoicQuotes.DataCase</code>: Usamos las herramientas para crear pruebas unitarias las cuales vienen incluidas en <em>Phoenix</em>. En este caso es una prueba unitaria que utilizará la base de datos. Este módulo esta definido en el archivo <code>test/support/data_case.ex</code>.</p>
</li>
<li>
<p><code>alias StoicQuotes.Quotes.Quote</code>: Asignamos un alias al esquema para usarlo más fácilmente.</p>
</li>
<li>
<p><code>describe "quote schema field and types tests"</code>: Crea un nuevo grupo para que varias pruebas estén cohesionadas en un mismo lugar.</p>
</li>
<li>
<p><code>test "that schema has the correct fields and types"</code>: Se crea la prueba unitaria que deberá ser implementada.</p>
</li>
<li>
<p><code>assert MapSet.new(expected_fields_and_types) == MapSet.new(actual_fields_and_types)</code>: El uso de <code>assert</code> permite informar el éxito o fracaso de una prueba, en este caso validamos que dos conjuntos sean iguales.</p>
</li>
<li>
<p><code>Quote.<em>schema</em>(:type, field)</code>: Devuelve el tipo de campo dentro del esquema.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para ejecutar la prueba solo debemos usar <code>mix test</code>,
pero si se desea solamente probar un archivo se puede proporcionar en el comando.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix test/stoic_quotes/quotes/schema_test.exs</code></pre>
</div>
</div>
<div class="paragraph">
<p>O tambien puede ser utilizando la función <code>describe</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix test --only describe:"quote schema field and types tests" test/stoic_quotes/quotes/schema_test.exs</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-3-pruebas-de-ecto-changeset"><a class="anchor" href="#paso-3-pruebas-de-ecto-changeset"></a>Paso 3: Pruebas de Ecto Changeset</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ahora se realizarán las pruebas de las validaciones, esto permitirá determinar
si las validaciones están correctamente establecidas y detectar cualquier problema con ellas.</p>
</div>
<div class="listingblock">
<div class="title">test/stoic_quotes/quotes/schema_test.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">describe "changeset/2" do
  test "that changeset with valid params is valid" do
    params = %{
      "author" =&gt; "Marcus Aurelius",
      "source" =&gt; "Meditations",
      "quote" =&gt;
        "You have power over your mind — not outside events. Realize this, and you will find strength."
    }

    changeset = Quote.changeset(%Quote{}, params)

    assert %Ecto.Changeset{valid?: true, changes: _} = changeset
  end

  test "that changeset with invalid params is invalid" do
    params = %{
      "author" =&gt; "",
      "source" =&gt; "Meditations",
      "quote" =&gt;
        "You have power over your mind — not outside events. Realize this, and you will find strength."
    }

    changeset = Quote.changeset(%Quote{}, params)

    assert %Ecto.Changeset{
             valid?: false,
             errors: [{:author, {"can't be blank", [validation: :required]}}]
           } =
             changeset

    params = %{
      "author" =&gt; "Marcus Aurelius",
      "source" =&gt; "",
      "quote" =&gt;
        "You have power over your mind — not outside events. Realize this, and you will find strength."
    }

    changeset = Quote.changeset(%Quote{}, params)

    assert %Ecto.Changeset{
             valid?: false,
             errors: [{:source, {"can't be blank", [validation: :required]}}]
           } =
             changeset

    params = %{
      "author" =&gt; "Marcus Aurelius",
      "source" =&gt; "Meditations",
      "quote" =&gt; ""
    }

    changeset = Quote.changeset(%Quote{}, params)

    assert %Ecto.Changeset{
             valid?: false,
             errors: [{:quote, {"can't be blank", [validation: :required]}}]
           } =
             changeset
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>También añadimos una validación para la función <code>new/1</code> donde comprobaremos
que siempre devuelva un <em>changeset</em>.</p>
</div>
<div class="listingblock">
<div class="title">test/stoic_quotes/quotes/schema_test.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">describe "new/1" do
  test "that returns a changeset" do
    params = %{
      "author" =&gt; "Marcus Aurelius",
      "source" =&gt; "Meditations",
      "quote" =&gt;
        "You have power over your mind — not outside events. Realize this, and you will find strength."
    }

    changeset = Quote.new(params)

    assert %Ecto.Changeset{valid?: true, changes: _} = changeset
  end
end</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-4-pruebas-de-contexto"><a class="anchor" href="#paso-4-pruebas-de-contexto"></a>Paso 4: Pruebas de Contexto</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Las pruebas de contexto fueron creadas automáticamente por el generador <code>phx.gen.context</code>.
Se pueden ver dentro del archivo <code>test/stoic_quotes/quotes_test.exs</code>, pero se recomienda
mover el archivo al directorio <code>test/stoic_quotes/quotes/quotes_test.exs</code> para que tenga cohesión
con las pruebas del esquema <code>test/stoic_quotes/quotes/schema_test.exs</code>.</p>
</div>
<div class="listingblock">
<div class="title">test/stoic_quotes/quotes_test.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotes.Tests.Contexts.QuotesContextTest do
  use StoicQuotes.DataCase

  alias StoicQuotes.Quotes

  describe "quotes" do
    alias StoicQuotes.Quotes.Quote

    import StoicQuotes.QuotesFixtures

    @invalid_attrs %{author: nil, source: nil, quote: nil}

    test "list_quotes/0 returns all quotes" do
      quote = quote_fixture()
      assert Quotes.list_quotes() == [quote]
    end
# ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que se puede destacar es el uso de <code>Fixtures</code> (<code>import StoicQuotes.QuotesFixtures</code>).
Esto es una herramienta de pruebas que permite tener un entorno predefinido por ejemplo
archivos o valores de base de datos que facilitan la creación de pruebas.</p>
</div>
<div class="paragraph">
<p>Si vamos al archivo <code>test/support/fixtures/quotes_fixtures.ex</code>
veremos que simplemente genera un nuevo registro en la base de datos
y es utilizado en las pruebas de contexto como <code>quote = quote_fixture()</code>.</p>
</div>
<div class="listingblock">
<div class="title">test/support/fixtures/quotes_fixtures.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotes.QuotesFixtures do
  @moduledoc """
  This module defines test helpers for creating
  entities via the `StoicQuotes.Quotes` context.
  """

  @doc """
  Generate a quote.
  """
  def quote_fixture(attrs \\ %{}) do
    {:ok, quote} =
      attrs
      |&gt; Enum.into(%{
        author: "some author",
        quote: "some quote",
        source: "some source"
      })
      |&gt; StoicQuotes.Quotes.create_quote()

    quote
  end
end</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-5-pruebas-de-endpoint-rest"><a class="anchor" href="#paso-5-pruebas-de-endpoint-rest"></a>Paso 5: Pruebas de Endpoint Rest</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para probar los endpoints rest debemos crear un nuevo archivo
en <code>test/stoic_quotes_web/controllers/quotes_controller_test.exs</code>.</p>
</div>
<div class="paragraph">
<p>Para esto probaremos los endpoints definidos en el router</p>
</div>
<div class="listingblock">
<div class="title">router.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">scope "/api", StoicQuotesWeb do
  pipe_through(:api)
  get("/quotes", QuotesController, :index)
  get("/quotes/random", QuotesController, :show)
end</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">test/stoic_quotes_web/controllers/quotes_controller_test.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotesWeb.Tests.Controllers.QuotesControllerTest do
  use StoicQuotesWeb.ConnCase
  import StoicQuotes.QuotesFixtures

  describe "/api/quotes" do
    test "GET /api/quotes", %{conn: conn} do
      quote_fixture(%{quote: "1"})
      quote_fixture(%{quote: "2"})

      conn = get(conn, ~p"/api/quotes")

      assert [
               %{
                 "author" =&gt; "some author",
                 "quote" =&gt; "1",
                 "source" =&gt; "some source"
               },
               %{
                 "author" =&gt; "some author",
                 "quote" =&gt; "2",
                 "source" =&gt; "some source"
               }
             ] = json_response(conn, 200)["data"]
    end

    test "GET /api/quotes/random", %{conn: conn} do
      quote_fixture()
      conn = get(conn, ~p"/api/quotes/random")

      assert %{
               "author" =&gt; "some author",
               "quote" =&gt; "some quote",
               "source" =&gt; "some source"
             } = json_response(conn, 200)["data"]
    end
  end
end</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>use StoicQuotesWeb.ConnCase</code>: Debemos usar el tipo de prueba <em>ConnCase</em> para poder acceder a levantar el servidor y realizar pruebas. Este módulo esta definido en el archivo <code>test/support/conn_case.ex</code>.</p>
</li>
<li>
<p><code>conn = get(conn, ~p"/api/quotes")</code>: Obtenemos el resultado de llamar al endpoint <code>/api/quotes</code>.</p>
</li>
<li>
<p><code>json_response(conn, 200)["data"]</code>: Obtenemos la respuesta en formato json y el contenido de la propiedad "data" para realizar la comparación.</p>
</li>
<li>
<p><code>~p"/api/quotes"</code>: <code>~p</code> es un sigilo (macro) de <em>Phoenix</em> que permite verificar que la ruta ingresada existe en el router, lo cual es muy recomendable. Es parte de lo que se conoce como <a href="https://hexdocs.pm/phoenix/routing.html#verified-routes">verified routes</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-6-pruebas-de-liveview"><a class="anchor" href="#paso-6-pruebas-de-liveview"></a>Paso 6: Pruebas de LiveView</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ahora se realizarán las pruebas del formulario hecho con <em>LiveView</em>.
El cual se muestra en la siguiente ruta.</p>
</div>
<div class="listingblock">
<div class="title">router.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">scope "/", StoicQuotesWeb do
  pipe_through(:browser)

  live("/", Live.QuotesForm, :live)
end</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">test/stoic_quotes_web/live/quotes_form_test.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotesWeb.Tests.Live.QuotesFormTest do
  use StoicQuotesWeb.ConnCase
  import Phoenix.LiveViewTest

  describe "LiveView quotes form page tests" do
    test "that valid form saving is done", %{conn: conn} do
      {:ok, lv, _html} =
        live(
          conn,
          ~p"/"
        )

      lv
      |&gt; form("form", %{
        "author" =&gt; "some author",
        "source" =&gt; "some source",
        "quote" =&gt; "some quote"
      })
      |&gt; render_submit()

      conn = get(conn, ~p"/api/quotes")

      assert [
               %{
                 "author" =&gt; "some author",
                 "quote" =&gt; "some quote",
                 "source" =&gt; "some source"
               }
             ] = json_response(conn, 200)["data"]
    end

    test "that invalid form shows errors", %{conn: conn} do
      {:ok, lv, _html} =
        live(
          conn,
          ~p"/"
        )

      result =
        lv
        |&gt; form("form", %{
          "author" =&gt; "",
          "source" =&gt; "",
          "quote" =&gt; ""
        })
        |&gt; render_submit()

      assert result =~ "can&amp;#39;t be blank"
    end

    test "that valid form cannot save duplicates", %{conn: conn} do
      {:ok, lv, _html} =
        live(
          conn,
          ~p"/"
        )

      lv
      |&gt; form("form", %{
        "author" =&gt; "some author",
        "source" =&gt; "some source",
        "quote" =&gt; "some quote"
      })
      |&gt; render_submit()

      result =
        lv
        |&gt; form("form", %{
          "author" =&gt; "some author",
          "source" =&gt; "some source",
          "quote" =&gt; "some quote"
        })
        |&gt; render_submit()

      assert result =~ "There was an error saving the Quote"
    end
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Podemos ver que realizar pruebas con <em>LiveView</em> es muy similar a realizar pruebas con endpoints json.
Sin embargo hay algunos códigos que se deben explicar como los siguientes:</p>
</div>
<div class="paragraph">
<p>El siguiente código inicializa la estructura de <code>lv</code> que puede ser usada por otras funciones
para renderizar la página.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">{:ok, lv, _html} =
  live(
    conn,
    ~p"/"
  )</code></pre>
</div>
</div>
<div class="paragraph">
<p>En el siguiente código se llama a funciones especiales de <em>LiveView</em> como <code>form("elemento html", parametros)</code> y <code>render_submit()</code>
que permiten realizar el envío de un formulario.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">lv
|&gt; form("form", %{
  "author" =&gt; "",
  "source" =&gt; "",
  "quote" =&gt; ""
})
|&gt; render_submit()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pasos-finales"><a class="anchor" href="#pasos-finales"></a>Pasos Finales</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Se ha realizado una aplicación completa con <em>Phoenix</em> y <em>LiveView</em>
desde una simple API Rest a una suite de pruebas unitarias.</p>
</div>
<div class="paragraph">
<p>Se pueden ver los siguientes conceptos para profundizar:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.tddphoenix.com/">Desarrollo con TDD (Test Driven Development)</a>.</p>
</li>
<li>
<p><a href="https://hexdocs.pm/ecto/testing-with-ecto.html">Testing Ecto</a>.</p>
</li>
<li>
<p><a href="https://hexdocs.pm/propcheck/readme.html">Property Testing</a>.</p>
</li>
<li>
<p><a href="https://fly.io/phoenix-files/forms-testing/">Testing LiveView</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="liveview.html">LiveView: Stoic API</a></span>
  <span class="next"><a href="commands.html">Makefiles</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../_/js/site.js" data-ui-root-path="../_"></script>
<script async src="../_/js/vendor/highlight.js"></script>
<script src="../_/js/vendor/lunr.js"></script>
<script src="../_/js/search-ui.js" id="search-ui-script" data-site-root-path=".." data-snippet-length="100" data-stylesheet="../_/css/search.css"></script>
<script async src="../search-index.js"></script>
  </body>
</html>
