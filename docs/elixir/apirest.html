<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>REST: Stoic API :: Elixir Full-Stack</title>
    <link rel="canonical" href="https://elixircl.github.io/elixir-fullstack/elixir/apirest.html">
    <link rel="prev" href="elixir.html">
    <link rel="next" href="liveview.html">
    <meta name="generator" content="Antora 3.1.12">
    <link rel="stylesheet" href="../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://elixircl.github.io/elixir-fullstack">Elixir Full-Stack</a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <!--
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
    -->
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="ROOT" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">Elixir Full-Stack</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Historia</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../history/chapter.html">Historia de la World Wide Web y Aplicaciones Móviles</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Ecosistema Tecnológico y Laboral</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ecosystem/jobs.html">Mundo Laboral y su Estado del Arte</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ecosystem/web.html">Ecosistema Web</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ecosystem/llm.html">Large Language Models (LLM)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Ingeniería en Software</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../swe/stages.html">Etapas del Desarrollo de un Producto de Software</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../swe/patterns.html">Patrones y Arquitecturas de Software</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../swe/adr.html">Arquitecture Decision Records</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../swe/prd.html">Documento de Requerimiento de Producto (Product Requirement Document - PRD)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../swe/wow.html">Way of Work</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../swe/uat.html">Pruebas de Aceptación de Usuario (User Aceptance Testing - UAT)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../swe/deprecation.html">Versionado y Política de Compatibilidad y Obsolescencia</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Github</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../github/chapter.html">Github, Static Site Generators, Markdown, Linux y Vim</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Hostings</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../hosting/chapter.html">Hosting, Dominios y Cpanel</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Networking</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../networking/chapter.html">Redes e Internet</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">HTTP</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../http/chapter.html">HTTP, JSON y APIS</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">HTML</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../html/chapter.html">HTML, CSS y GIT</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Javascript</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../javascript/chapter.html">Frontend con Javascript</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Elixir</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="elixir.html">El Lenguaje Elixir</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="apirest.html">REST: Stoic API</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="liveview.html">LiveView: Stoic API</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing.html">Testing: Stoic API</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Aplicaciones Móviles</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../mobile/chapter.html">Aplicaciones Móviles</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">DevOps</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../devops/devenvs.html">Ambientes de Desarrollo</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../devops/observability.html">Observabilidad e Instrumentación</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../devops/dora.html">Métricas DORA</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../devops/golden.html">Golden Signals</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Elixir Full-Stack</span>
    <span class="version">Spanish</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../index.html">Elixir Full-Stack</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">Spanish</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Elixir Full-Stack</a></li>
    <li>Elixir</li>
    <li><a href="apirest.html">REST: Stoic API</a></li>
  </ul>
</nav>
<div class="edit-this-page"><a href="file:///antora/./modules/elixir/pages/apirest.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">REST: Stoic API</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>En este proyecto basado en el tutorial <a href="https://bryananthonio.com/blog/creating-simple-rest-api-elixir-phoenix/">Simple Rest API with Phoenix</a>
se creará una API Rest para devolver citas de filósofos estóicos.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-1-crear-el-proyecto-y-la-base-de-datos"><a class="anchor" href="#paso-1-crear-el-proyecto-y-la-base-de-datos"></a>Paso 1: Crear el proyecto y la base de datos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Se utilizará <em>SQLite3</em> para simplificar la configuración.
Primero creamos un nuevo proyecto dando el parámetro de <code>--database=sqlite3</code> ya que
el valor predeterminado es <em>Postgres</em>.</p>
</div>
<div class="paragraph">
<p>También se creará la base de datos con el comando <code>ecto.create</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix phx.new stoic_quotes --database=sqlite3
$ cd stoic_quotes
$ mix ecto.create</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-2-crear-las-migraciones"><a class="anchor" href="#paso-2-crear-las-migraciones"></a>Paso 2: Crear las migraciones</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Una migración es un control de versiones para la base de datos que define cambios en su
esquema (crear, modificar o eliminar tablas, columnas, llaves primarias, relaciones e índices) en archivos de código <em>Elixir</em>,
en lugar de usar archivos SQL tradicionales. Esta herramienta permite mantener la base de datos sincronizada
con la aplicación, facilita la colaboración en equipo al evitar
conflictos y permite desplegar cambios de forma sencilla en producción.</p>
</div>
<div class="paragraph">
<p>El comando que proporcionada <em>Phoenix</em> para simplificar la creación de los esquemas y migraciones
es <a href="https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.Context.html"><code>phx.gen.context &lt;nombre de tabla en el esquema (plural)&gt; &lt;recurso (singular)&gt; &lt;nombre de archivo&gt; &lt;attributos&gt;:&lt;tipo&gt;</code></a>.
Esto es una herramienta llamada "generador" (<a href="https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.html#module-crud-related-generators">puede encontrar más acá</a>)
y sirven para simplificar tareas comunes y recurrentes como crear recursos.</p>
</div>
<div class="paragraph">
<p>La tabla a crear es la siguiente:</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/diag-0c0cacf977b2574b58d8c657d73b91b2339f6b60.svg" alt="Diagram">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix phx.gen.context Quotes Quote quotes quote:text author:string source:string</code></pre>
</div>
</div>
<div class="paragraph">
<p>El comando debío crear la siguiente migración ubicada en <code>priv/repo/migrations/*_create_quotes.exs</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotes.Repo.Migrations.CreateQuotes do
  use Ecto.Migration

  def change do
    create table(:quotes) do
      add :quote, :text
      add :author, :string
      add :source, :string

      timestamps(type: :utc_datetime)
    end
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Y también un esquema ubicado en <code>lib/stoic_quotes/quotes/quote.ex</code>.
Notemos la función <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html">changeset</a>,
la cual realiza las <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html#module-validations-and-constraints">validaciones</a> antes de permitir insertar un nuevo registro
en la base de datos.</p>
</div>
<div class="listingblock">
<div class="title">lib/stoic_quotes/quotes/quote.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotes.Quotes.Quote do
  use Ecto.Schema
  import Ecto.Changeset

  schema "quotes" do
    field :quote, :string
    field :author, :string
    field :source, :string

    timestamps(type: :utc_datetime)
  end

  @doc false
  def changeset(quote, attrs) do
    quote
    |&gt; cast(attrs, [:quote, :author, :source])
    |&gt; validate_required([:quote, :author, :source])
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adicionalmente se puede mejorar el <em>changeset</em> ya que vemos que se repite los campos
<code>[:quote, :author, :source]</code>. Para esto utilizaremos un attributo especial llamado <code><em>schema</em>(:fields)</code> dentro del módulo <code><em>MODULE</em></code>.
Por lo que podremos utilizarlo en las funciones  <code>cast</code> y <code>validate_required</code>.</p>
</div>
<div class="paragraph">
<p>Para esto definimos una nueva función que lo retorne:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">def fields() do
  __MODULE__.__schema__(:fields)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Además necesitamos definir un atributo que permita saber que campos son opcionales.
Para esto realizaremos la operación <code>fields()&#8201;&#8212;&#8201;@optional_fields</code> para obtener todos
los campos requeridos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">@optional_fields [:id, :inserted_at, :updated_at]

def required_fields() do
  fields() -- @optional_fields
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finalmente el archivo quedará como lo siguiente:</p>
</div>
<div class="listingblock">
<div class="title">lib/stoic_quotes/quotes/quote.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotes.Quotes.Quote do
  use Ecto.Schema
  import Ecto.Changeset

  @optional_fields [:id, :inserted_at, :updated_at]

  schema "quotes" do
    field :quote, :string
    field :author, :string
    field :source, :string

    timestamps(type: :utc_datetime)
  end

  def fields() do
    __MODULE__.__schema__(:fields)
  end

  def required_fields() do
    fields() -- @optional_fields
  end

  @doc false
  def changeset(quote, attrs) do
    quote
    |&gt; cast(attrs, fields())
    |&gt; validate_required(required_fields())
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El esquema es utilizado por el contexto de <em>Phoenix</em>, también conocido
como dominio (en Domain Driven Desing), modelo (en MVC) o reglas de negocio (en capas). Es un archivo utilizado como capa
superior al esquema y que permite realizar operaciones comunes como consultas, modificaciones o inserciones.
Esta ubicado en <code>lib/stoic_quotes/quotes.ex</code>. Si bien tiene varias funciones, es recomendable subdividir
este contexto en archivos con operaciones de lectura y escritura para evitar que se convierta en un archivo demasiado grande,
esto se llama <em>Command - Query Responsability Segregation</em> (CQRS), segregación de la responsabilidad entre comandos y consultas.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">quotes/
  quotes.ex (bussiness logic)
  quote.ex (schema)
  commands.ex (insert, update, delete)
  queries.ex (select)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para fines pedagógicos solamente nos enfocaremos en un archivo común.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotes.Quotes do
  @moduledoc """
  The Quotes context.
  """

  import Ecto.Query, warn: false
  alias StoicQuotes.Repo

  alias StoicQuotes.Quotes.Quote

  @doc """
  Returns the list of quotes.

  ## Examples

      iex&gt; list_quotes()
      [%Quote{}, ...]

  """
  def list_quotes do
    Repo.all(Quote)
  end

  @doc """
  Gets a single quote.

  Raises `Ecto.NoResultsError` if the Quote does not exist.

  ## Examples

      iex&gt; get_quote!(123)
      %Quote{}

      iex&gt; get_quote!(456)
      ** (Ecto.NoResultsError)

  """
  def get_quote!(id), do: Repo.get!(Quote, id)

  @doc """
  Creates a quote.

  ## Examples

      iex&gt; create_quote(%{field: value})
      {:ok, %Quote{}}

      iex&gt; create_quote(%{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def create_quote(attrs) do
    %Quote{}
    |&gt; Quote.changeset(attrs)
    |&gt; Repo.insert()
  end

  @doc """
  Updates a quote.

  ## Examples

      iex&gt; update_quote(quote, %{field: new_value})
      {:ok, %Quote{}}

      iex&gt; update_quote(quote, %{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def update_quote(%Quote{} = quote, attrs) do
    quote
    |&gt; Quote.changeset(attrs)
    |&gt; Repo.update()
  end

  @doc """
  Deletes a quote.

  ## Examples

      iex&gt; delete_quote(quote)
      {:ok, %Quote{}}

      iex&gt; delete_quote(quote)
      {:error, %Ecto.Changeset{}}

  """
  def delete_quote(%Quote{} = quote) do
    Repo.delete(quote)
  end

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking quote changes.

  ## Examples

      iex&gt; change_quote(quote)
      %Ecto.Changeset{data: %Quote{}}

  """
  def change_quote(%Quote{} = quote, attrs \\ %{}) do
    Quote.changeset(quote, attrs)
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La principal diferencia entre la migración y el esquema, es que la migración puede cambiar y esta íntimamente
ligada a la estructura de la base de datos. El esquema es una capa que puede mantenerse en el tiempo y no necesariamente tenga una migración asociada, aunque
es recomendable que ambos estén actualizados. La migración solo se utiliza al momento de ejecutar cambios en la base de datos por consola y con la aplicación apagada.
El esquema se puede utilizar durante la ejecución de la aplicación para almacenar, consultar y modificar los registros en la base de datos.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-3-crear-las-llaves-primarias-e-índices"><a class="anchor" href="#paso-3-crear-las-llaves-primarias-e-índices"></a>Paso 3: Crear las llaves primarias e índices</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ahora se darán restricciones a la base de datos para evitar datos duplicados
y mejorar la velocidad de lectura y consultas al tener índices.</p>
</div>
<div class="paragraph">
<p>Por defecto, cuando defines un esquema de <em>Ecto</em> sin especificar explícitamente una clave primaria,
<em>Ecto</em> asume una columna id de tipo :bigserial (o el equivalente para tu base de datos) que se
incrementa automáticamente y es única.</p>
</div>
<div class="paragraph">
<p>La línea <code>timestamps(type: :utc_datetime)</code> se encarga de crear automáticamente los campos <code>inserted_at</code> y <code>updated_at</code>.</p>
</div>
<div class="paragraph">
<p>Para añadir un índice de valor único añadimos al final de nuestra migración lo siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">create unique_index(:quotes, [:quote], name: :index_for_duplicate_quotes)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quedando el archivo como sigue</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotes.Repo.Migrations.CreateQuotes do
  use Ecto.Migration

  def change do
    create table(:quotes) do
      add :quote, :text
      add :author, :string
      add :source, :string

      timestamps(type: :utc_datetime)
    end

    create unique_index(:quotes, [:quote], name: :index_for_duplicate_quotes)
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>También actualizamos el esquema para reflejar este nuevo índice y restricción.
Añadiendo las siguientes línea al esquema (<code>lib/stoic_quotes/quotes/quote.ex</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">|&gt; unsafe_validate_unique(:quote, StoicQuotes.Repo)
|&gt; unique_constraint(:quote)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>unsafe_validate_unique(:quote, StoicQuotes.Repo)</code>: Valida de forma rápida consultando a la base de datos, ideal para los formularios. Puede tener condiciones de carrera por lo que solo es recomendable para validaciones rápidas.</p>
</li>
<li>
<p><code>unique_constraint(:quote)</code>: Intenta agregar un nuevo registro a la base de datos y arroja un error si la base de datos lo impide. Simplemente estamos diciendo a <em>Ecto</em> que el campo <code>quote</code> tiene una restricción de valor único y que debe considerar el error de la bd como parte de las validaciones.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Quedando como sigue</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotes.Quotes.Quote do
  use Ecto.Schema
  import Ecto.Changeset

  @optional_fields [:id, :inserted_at, :updated_at]

  schema "quotes" do
    field(:quote, :string)
    field(:author, :string)
    field(:source, :string)

    timestamps(type: :utc_datetime)
  end

  def fields() do
    __MODULE__.__schema__(:fields)
  end

  def required_fields() do
    fields() -- @optional_fields
  end

  @doc false
  def changeset(quote, attrs) do
    quote
    |&gt; cast(attrs, fields())
    |&gt; validate_required(required_fields())
    |&gt; unsafe_validate_unique(:quote, StoicQuotes.Repo)
    |&gt; unique_constraint(:quote)
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora simplemente ejecutamos la migración para crear las tablas en la base de datos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix ecto.migrate</code></pre>
</div>
</div>
<div class="paragraph">
<p>Debería crear una nueva tabla, la cual podemos verificar con un gestor de base de datos
como <a href="https://dbeaver.com/">DBeaver</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/tables.png" alt="tables">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-4-añadir-registros-a-la-base-de-datos"><a class="anchor" href="#paso-4-añadir-registros-a-la-base-de-datos"></a>Paso 4: Añadir registros a la base de datos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Tenemos un pequeño archivo <code>json</code> que tiene los datos necesarios.
Creamos un archivo llamado <code>quotes</code> dentro de <code>priv/repo</code>.</p>
</div>
<div class="listingblock">
<div class="title">priv/repo/quotes.json</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">[
  {
    "quote": "Seldom are any found unhappy from not observing what is in the minds of others. But such as observe not well the stirrings of their own souls must of necessity be unhappy.",
    "author": "Marcus Aurelius",
    "source": "Book II, Meditations"
  },

  {
    "quote": "Consider whence each thing came, of what it was compounded, into what it will be changed, how it will be with it when changed, and that it will suffer no evil.",
    "author": "Marcus Aurelius",
    "source": "Book XI, Meditations"
  },

  {
    "quote": "Accustom yourself as much as possible, when any one takes any action, to consider only: To what end is he working? But begin at home; and examine yourself first of all.",
    "author": "Marcus Aurelius",
    "source": "Book X, Meditations"
  }
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora es necesario crear las "semillas" o "seeds" que iniciarán los valores que nuestra
base de datos necesita. Este script solo es recomendable ejecutar cuando se inicia la base de datos,
sobre todo para establecer el ambiente de desarrollo y que tenga los datos necesarios para que
la aplicación funcione.</p>
</div>
<div class="paragraph">
<p>Editamos el archivo <code>priv/repo/seeds.exs</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">alias StoicQuotes.Quotes

# Read quotes from the JSON file
quotes_path = "priv/repo/quotes.json"
quotes_path
|&gt; File.read!()
|&gt; Jason.decode!()
|&gt; Enum.each(fn attrs -&gt;
	quote = %{quote: attrs["quote"], author: attrs["author"], source: attrs["source"]}
	case Quotes.create_quote(quote) do
		{:ok, _quote} -&gt; :ok
		{:error, _changeset} -&gt; :duplicate
	end
end)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Y ejecutamos el comando</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix run priv/repo/seeds.exs</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Los comandos de <code>mix</code> deben ser ejecutados en el mismo lugar donde esta presente el archivo <code>mix.exs</code>.
Podemos verificar usando los comandos <code>ls</code> y <code>pwd</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Si todo sale bien podremos verificar en <em>DBeaver</em> que los datos están presentes.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/seeds.png" alt="seeds">
</div>
</div>
<div class="paragraph">
<p>Si se quiere verificar por consola también se puede ejecutar el siguiente comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ iex -S mix
$ StoicQuotes.Quotes.list_quotes()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-5-construcción-de-rutas"><a class="anchor" href="#paso-5-construcción-de-rutas"></a>Paso 5: Construcción de Rutas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Esta API tendrá dos rutas principales:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/api/quotes/</code>: Lista todas las citas disponibles.</p>
</li>
<li>
<p><code>/api/quotes/random</code>: Lista una cita aleatoria.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para esto se debe editar el <code>router</code> ubicado en <code>lib/stoic_quotes_web/router.ex</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">scope "/api", StoicQuotesWeb do
	pipe_through :api
	get "/quotes", QuotesController, :index
	get "/quotes/random", QuotesController, :show
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El siguiente código nos indica lo siguiente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>scope</code>: Es una macro que acepta como parámetro la ruta base (endpoint) y el módulo base para buscar los controladores.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir"># las rutas tendrán como base /api y como base el módulo StoicQuotesWeb
scope "/api", StoicQuotesWeb do</code></pre>
</div>
</div>
<div class="paragraph">
<p>El siguiente código nos indica lo siguiente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>pipe_through</code>: Es una macro que gatillará lo definido en el pipeline <code>:api</code> para todos los requests que cumplan el <code>scope "/api"</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">pipe_through :api</code></pre>
</div>
</div>
<div class="paragraph">
<p>El pipeline de <code>:api</code> establece un pipeline para aceptar requests del formato <code>json</code>,
se define como lo siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">pipeline :api do
  plug(:accepts, ["json"])
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El código nos indica lo siguiente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>get</code>: Es la función identificada con el verbo HTTP a usar en la ruta. Por ejemplo si usamos <em>POST</em> no encontrará la ruta.</p>
</li>
<li>
<p><code>/quotes</code>: Es la ruta donde deberemos hacer las llamadas HTTP. Como estamos dentro del scope <code>/api/</code> la ruta completa será <code>/api/quotes</code></p>
</li>
<li>
<p><code>QuotesController</code>: Es el módulo donde se encontrarán las funciones para procesar el request. Como estamos dentro del scope <code>StoicQuotesWeb</code> el módulo usado será <code>StoicQuotesWeb.QuotesController</code>.</p>
</li>
<li>
<p><code>:index</code>: Es un átomo que permite identificar el request, utilizado en el módulo para segregar las funcionalidad de manejar el request. En este caso se asociará a una función dentro del controlador llamada <code>index</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir"># verbo http, "/ruta", modulo, parámetro
get "/quotes", QuotesController, :index</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quedando el archivo como lo siguiente:</p>
</div>
<div class="listingblock">
<div class="title">stoic_quotes_web/router.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotesWeb.Router do
  use StoicQuotesWeb, :router

  pipeline :browser do
    plug(:accepts, ["html"])
    plug(:fetch_session)
    plug(:fetch_live_flash)
    plug(:put_root_layout, html: {StoicQuotesWeb.Layouts, :root})
    plug(:protect_from_forgery)
    plug(:put_secure_browser_headers)
  end

  pipeline :api do
    plug(:accepts, ["json"])
  end

  scope "/", StoicQuotesWeb do
    pipe_through(:browser)

    get("/", PageController, :home)
  end

  scope "/api", StoicQuotesWeb do
    pipe_through(:api)
    get("/quotes", QuotesController, :index)
    get("/quotes/random", QuotesController, :show)
  end

  # Enable LiveDashboard and Swoosh mailbox preview in development
  if Application.compile_env(:stoic_quotes, :dev_routes) do
    # If you want to use the LiveDashboard in production, you should put
    # it behind authentication and allow only admins to access it.
    # If your application does not have an admins-only section yet,
    # you can use Plug.BasicAuth to set up some basic authentication
    # as long as you are also using SSL (which you should anyway).
    import Phoenix.LiveDashboard.Router

    scope "/dev" do
      pipe_through(:browser)

      live_dashboard("/dashboard", metrics: StoicQuotesWeb.Telemetry)
      forward("/mailbox", Plug.Swoosh.MailboxPreview)
    end
  end
end</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-6-crear-el-controlador"><a class="anchor" href="#paso-6-crear-el-controlador"></a>Paso 6: Crear el controlador</h2>
<div class="sectionbody">
<div class="paragraph">
<p>El <a href="https://hexdocs.pm/phoenix/controllers.html#actions">controlador</a> es donde se alojan las funciones que responderán a las requests definidas en el router.
Por lo que se debe crear un nuevo archivo llamado  <code>quotes_controller.ex</code> dentro de <code>stoic_quotes_web/controllers/quotes_controller.ex</code>
y tener el siguiente contenido:</p>
</div>
<div class="listingblock">
<div class="title">stoic_quotes_web/controllers/quotes_controller.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotesWeb.QuotesController do
  use Phoenix.Controller, formats: [:json]
  alias StoicQuotes.Quotes

  def index(conn, _params) do
    quotes = %{quotes: Quotes.list_quotes()}
    render(conn, :index, quotes)
  end

  def show(conn, _params) do
    quote = %{quote: Quotes.get_random_quote()}
    render(conn, :show, quote)
  end
end</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>def index(conn, _params)</code>: Notar como cada función recibe un parámetro conexión (conn), donde tiene los detalles del request, el cual se usará para ser enviado a otras funciones como <code>render</code> y el resto de parámetros (params) donde se reciben los distintos parámetros definidos en la ruta principal.</p>
</li>
<li>
<p><code>use Phoenix.Controller, formats: [:json]</code>: Define a este módulo como un controlador que responde con <code>json</code>.</p>
</li>
<li>
<p><code>render(conn, :index, quotes)</code>: Utiliza la <a href="https://hexdocs.pm/phoenix/Phoenix.Controller.html#module-rendering-and-layouts">función render</a> que llama a la vista y genera el json final pasándole los parámetros desde el controlador.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-7-crear-la-vista"><a class="anchor" href="#paso-7-crear-la-vista"></a>Paso 7: Crear la vista</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La vista será principalmente un <code>json</code>, por lo que tenemos que crear un nuevo archivo llamado <code>quotes_json.ex</code>
dentro del mismo directorio que <code>quotes_controller.ex</code>.</p>
</div>
<div class="paragraph">
<p>Notar que tiene las mismas funciones usadas en el controlador, con la excepción de que definen su parámetro
como el dato a mostrar, que es pasado a la función <code>render</code> usada en el controlador.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule StoicQuotesWeb.QuotesJSON do
	alias StoicQuotes.Quotes.Quote

	def index(%{quotes: quotes}) do
		%{data: for(quote &lt;- quotes, do: data(quote))}
	end

	def show(%{quote: quote}) do
		%{data: data(quote)}
	end

	defp data(%Quote{} = datum) do
		%{
			quote: datum.quote,
			author: datum.author,
			source: datum.source
		}
	end
end</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-8-modificar-el-contexto"><a class="anchor" href="#paso-8-modificar-el-contexto"></a>Paso 8: Modificar el contexto</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Debemos modificar el contexto (o modelo) para añadir la función <code>Quotes.get_random_quote()</code> usada en el controlador
en su función <code>show</code>.</p>
</div>
<div class="listingblock">
<div class="title">lib/stoic_quotes/quotes.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">@doc """
Gets a random quote

## Examples

    iex&gt; get_random_quote()
    %Quote{}
"""
def get_random_quote() do
  query =
    from(q in Quote,
      order_by: fragment("RANDOM()"),
      limit: 1
    )

  Repo.one(query)
end</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-9-pruebas-manuales"><a class="anchor" href="#paso-9-pruebas-manuales"></a>Paso 9: Pruebas Manuales</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para las pruebas se puede usar <code>curl</code> o crear una colección con <a href="https://www.usebruno.com/">Bruno</a>.
Las pruebas automatizadas con <code>mix test</code> serán implementadas en un proyecto futuro.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ iex -S mix phx.server
$ curl -i localhost:4000/api/quotes/
$ curl -i localhost:4000/api/quotes/random</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">➜  ~ curl -i localhost:4000/api/quotes/
HTTP/1.1 200 OK
date: Sat, 27 Sep 2025 03:16:50 GMT
content-length: 723
vary: accept-encoding
content-type: application/json; charset=utf-8
cache-control: max-age=0, private, must-revalidate
x-request-id: GGkFWTujtWGncGAAAAGC

{"data":[{"author":"Marcus Aurelius","source":"Book II, Meditations","quote":"Seldom are any found unhappy from not observing what is in the minds of others. But such as observe not well the stirrings of their own souls must of necessity be unhappy."},{"author":"Marcus Aurelius","source":"Book XI, Meditations","quote":"Consider whence each thing came, of what it was compounded, into what it will be changed, how it will be with it when changed, and that it will suffer no evil."},{"author":"Marcus Aurelius","source":"Book X, Meditations","quote":"Accustom yourself as much as possible, when any one takes any action, to consider only: To what end is he working? But begin at home; and examine yourself first of all."}]}%</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="paso-10-siguientes-pasos"><a class="anchor" href="#paso-10-siguientes-pasos"></a>Paso 10: Siguientes Pasos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ahora se tiene una API Rest. En el siguiente tutorial se verá como crear un formulario
que permita añadir desde la web una nueva cita estóica utilizando <em>LiveView</em>.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="elixir.html">El Lenguaje Elixir</a></span>
  <span class="next"><a href="liveview.html">LiveView: Stoic API</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../_/js/site.js" data-ui-root-path="../_"></script>
<script async src="../_/js/vendor/highlight.js"></script>
<script src="../_/js/vendor/lunr.js"></script>
<script src="../_/js/search-ui.js" id="search-ui-script" data-site-root-path=".." data-snippet-length="100" data-stylesheet="../_/css/search.css"></script>
<script async src="../search-index.js"></script>
  </body>
</html>
